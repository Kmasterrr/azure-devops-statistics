# Azure DevOps Statistics Collection Pipeline
# Collects statistics across ALL projects in the organization
# Uses a PAT stored as a secret pipeline variable
# Report summary displays directly in pipeline results (no extensions needed)
#
# SETUP:
# 1. Create a PAT with these scopes:
#    - Code: Read
#    - Build: Read
#    - Work Items: Read
#    - Graph: Read
#    - Project and Team: Read
#    - Member Entitlement Management: Read
# 2. In the pipeline, add a secret variable named "ADOS_PAT" with the PAT value

trigger: none  # Manual trigger only

schedules:
  - cron: "0 6 * * 0"  # Weekly on Sunday at 6 AM UTC
    displayName: Weekly Statistics Collection
    branches:
      include:
        - master
    always: true

pool:
  vmImage: 'windows-latest'

variables:
  - name: outputPath
    value: '$(Build.SourcesDirectory)/data'

stages:
  - stage: CollectStatistics
    displayName: 'Collect Azure DevOps Statistics'
    jobs:
      - job: CollectAndReport
        displayName: 'Collect Statistics and Generate Report'
        timeoutInMinutes: 60
        steps:
          # Display pipeline info
          - script: |
              echo "Pipeline: $(Build.DefinitionName)"
              echo "Build Number: $(Build.BuildNumber)"
              echo "Collection URI: $(System.TeamFoundationCollectionUri)"
            displayName: 'Display Pipeline Info'

          # Validate PAT is configured
          - powershell: |
              if (-not $env:ADOS_PAT -or $env:ADOS_PAT -eq '') {
                Write-Error "ADOS_PAT secret variable is not set!"
                Write-Error "Please add a secret variable named 'ADOS_PAT' with your Personal Access Token."
                Write-Error "Required PAT scopes: Code (Read), Build (Read), Work Items (Read), Graph (Read), Project and Team (Read), Member Entitlement Management (Read)"
                exit 1
              }
              Write-Host "✓ PAT configured"
            displayName: 'Validate PAT Configuration'
            env:
              ADOS_PAT: $(ADOS_PAT)

          # Extract organization name and collect statistics
          - powershell: |
              # Extract organization name from collection URI
              # Format: https://dev.azure.com/orgname/ or https://orgname.visualstudio.com/
              $collectionUri = '$(System.TeamFoundationCollectionUri)'.TrimEnd('/')
              
              if ($collectionUri -match 'dev\.azure\.com/([^/]+)') {
                $organization = $Matches[1]
              } elseif ($collectionUri -match '([^/]+)\.visualstudio\.com') {
                $organization = $Matches[1]
              } else {
                $organization = $collectionUri.Split('/')[-1]
              }
              
              Write-Host "Detected Organization: $organization"
              Write-Host "##vso[task.setvariable variable=organizationName]$organization"
              
              # Set environment variables for the collection script
              $env:ADOS_ORGANIZATION = $organization
              $env:ADOS_PAT = $env:PAT_VALUE
              
              Write-Host "Starting statistics collection..."
              Write-Host "Output path: $(outputPath)"
              
              # Run the collection script
              & "$(Build.SourcesDirectory)/Collect-Statistics-Fixed.ps1" -OutputPath "$(outputPath)" -Format "Both"
              
              if ($LASTEXITCODE -ne 0 -and $LASTEXITCODE -ne $null) {
                Write-Warning "Collection completed with exit code: $LASTEXITCODE"
              }
            displayName: 'Collect Azure DevOps Statistics'
            env:
              PAT_VALUE: $(ADOS_PAT)

          # Find the data directory
          - powershell: |
              $organization = '$(organizationName)'
              $basePath = "$(outputPath)/$organization"
              
              Write-Host "Looking for data in: $basePath"
              
              if (Test-Path $basePath) {
                $latestDir = Get-ChildItem -Path $basePath -Directory | 
                             Sort-Object Name -Descending | 
                             Select-Object -First 1
                
                if ($latestDir) {
                  $dataPath = $latestDir.FullName
                  Write-Host "Found data directory: $dataPath"
                  Write-Host "##vso[task.setvariable variable=dataPath]$dataPath"
                } else {
                  Write-Error "No date subdirectory found in $basePath"
                  exit 1
                }
              } else {
                Write-Error "Base path not found: $basePath"
                Get-ChildItem -Path "$(outputPath)" -Recurse -Directory | ForEach-Object { Write-Host $_.FullName }
                exit 1
              }
            displayName: 'Locate Data Directory'

          # Generate HTML Report
          - powershell: |
              $env:ADOS_ORGANIZATION = '$(organizationName)'
              
              Write-Host "Generating enhanced report from: $(dataPath)"
              
              & "$(Build.SourcesDirectory)/Generate-Report-Enhanced.ps1" -DataPath "$(dataPath)" -OutputFormat "HTML"
              
              # Verify report was created
              $reportPath = Join-Path "$(dataPath)" "Azure-DevOps-Report.html"
              if (Test-Path $reportPath) {
                Write-Host "✓ Report generated successfully: $reportPath"
              } else {
                Write-Error "Report file not found at: $reportPath"
                exit 1
              }
            displayName: 'Generate HTML Report'

          # List generated files
          - powershell: |
              Write-Host "`nGenerated files:"
              Get-ChildItem -Path "$(dataPath)" -File | 
                Select-Object Name, @{N='Size';E={"{0:N0} KB" -f ($_.Length/1KB)}} |
                Format-Table -AutoSize
            displayName: 'List Generated Files'

          # Copy to staging
          - task: CopyFiles@2
            displayName: 'Copy Report to Staging'
            inputs:
              SourceFolder: '$(dataPath)'
              Contents: |
                **/*.html
                **/*.json
              TargetFolder: '$(Build.ArtifactStagingDirectory)/report'

          # Generate Markdown Summary for Pipeline Display
          - powershell: |
              $mdPath = "$(Build.ArtifactStagingDirectory)/pipeline-summary.md"
              
              Write-Host "Generating pipeline summary..."
              
              & "$(Build.SourcesDirectory)/Generate-PipelineSummary.ps1" -DataPath "$(dataPath)" -OutputPath $mdPath -Organization "$(organizationName)"
              
              if (Test-Path $mdPath) {
                # This displays the markdown in the pipeline summary
                Write-Host "##vso[task.uploadsummary]$mdPath"
                Write-Host "Pipeline summary generated successfully"
              } else {
                Write-Warning "Pipeline summary was not generated"
              }
            displayName: 'Generate Pipeline Summary'

          # Publish as Pipeline Artifact
          - task: PublishPipelineArtifact@1
            displayName: 'Publish Report Artifact'
            inputs:
              targetPath: '$(Build.ArtifactStagingDirectory)/report'
              artifact: 'AzureDevOpsStatisticsReport'
              publishLocation: 'pipeline'

          # Summary
          - powershell: |
              Write-Host ""
              Write-Host "============================================" -ForegroundColor Green
              Write-Host "  Statistics Collection Complete!" -ForegroundColor Green  
              Write-Host "============================================" -ForegroundColor Green
              Write-Host ""
              Write-Host "Organization: $(organizationName)"
              Write-Host ""
              Write-Host "View results:"
              Write-Host "1. Summary is displayed in the pipeline 'Summary' tab above"
              Write-Host "2. Full HTML report: Artifacts → AzureDevOpsStatisticsReport"
            displayName: 'Display Summary'

          # Send notification to Microsoft Teams
          # Requires TEAMS_WEBHOOK_URL variable to be set (get this from Teams channel > Connectors > Incoming Webhook)
          - powershell: |
              $webhookUrl = $env:TEAMS_WEBHOOK
              
              if (-not $webhookUrl) {
                Write-Host "##vso[task.logissue type=warning]TEAMS_WEBHOOK_URL variable not set. Skipping Teams notification."
                exit 0
              }
              
              Write-Host "Sending notification to Teams..."
              
              # Build the artifact link
              $artifactUrl = "$(System.TeamFoundationCollectionUri)$(System.TeamProject)/_build/results?buildId=$(Build.BuildId)&view=artifacts&pathAsName=false&type=publishedArtifacts"
              $pipelineUrl = "$(System.TeamFoundationCollectionUri)$(System.TeamProject)/_build/results?buildId=$(Build.BuildId)&view=ms.vss-build-web.run-extensions-tab"
              
              # Load summary data
              $summaryPath = Join-Path "$(dataPath)" "Collection-Summary.json"
              $summary = $null
              if (Test-Path $summaryPath) {
                $summary = Get-Content $summaryPath | ConvertFrom-Json
              }
              
              # Extract values to ensure proper interpolation
              $orgName = "$(organizationName)"
              $duration = if ($summary.Duration) { "$($summary.Duration)".Split('.')[0] } else { "N/A" }
              $users = if ($summary.UsersCollected) { "$($summary.UsersCollected)" } else { "0" }
              $repos = if ($summary.RepositoriesCollected) { "$($summary.RepositoriesCollected)" } else { "0" }
              $commits = if ($summary.CommitsCollected) { "$($summary.CommitsCollected)" } else { "0" }
              $prs = if ($summary.PullRequestsCollected) { "$($summary.PullRequestsCollected)" } else { "0" }
              $workItems = if ($summary.WorkItemsCollected) { "$($summary.WorkItemsCollected)" } else { "0" }
              
              # Load scoring config
              $configPath = Join-Path "$(Build.SourcesDirectory)" "Config-ScoringWeights.ps1"
              if (Test-Path $configPath) {
                . $configPath
              } else {
                $Global:ScoringWeights = @{ PRsMerged = 5; CodeReviews = 4; PRsCreated = 3; WorkItems = 2; Commits = 0.5 }
              }
              
              # Calculate top 5 contributors (matching HTML report logic)
              $topContributors = @()
              $commitsPath = Join-Path "$(dataPath)" "GitCommits.json"
              $prsPath = Join-Path "$(dataPath)" "GitPullRequests.json"
              $workItemsPath = Join-Path "$(dataPath)" "WorkItems.json"
              
              if ((Test-Path $commitsPath) -or (Test-Path $prsPath)) {
                $commitsData = if (Test-Path $commitsPath) { Get-Content $commitsPath | ConvertFrom-Json } else { @{ data = @() } }
                $prsData = if (Test-Path $prsPath) { Get-Content $prsPath | ConvertFrom-Json } else { @{ data = @() } }
                $workItemsData = if (Test-Path $workItemsPath) { Get-Content $workItemsPath | ConvertFrom-Json } else { @{ data = @() } }
                
                $commitsList = if ($commitsData.data) { $commitsData.data } else { $commitsData }
                $prsList = if ($prsData.data) { $prsData.data } else { $prsData }
                $workItemsList = if ($workItemsData.data) { $workItemsData.data } else { $workItemsData }
                
                # Build team activity by NAME (matching HTML report)
                $teamActivity = @{}
                
                # Count commits
                foreach ($commit in $commitsList) {
                  $name = $commit.Author
                  if ($name) {
                    if (-not $teamActivity.ContainsKey($name)) {
                      $teamActivity[$name] = @{ Name = $name; Commits = 0; PRsCreated = 0; PRsMerged = 0; PRsReviewed = 0; WorkItemsAssigned = 0 }
                    }
                    $teamActivity[$name].Commits++
                  }
                }
                
                # Count PRs created, merged, and reviews
                foreach ($pr in $prsList) {
                  $creator = $pr.createdBy
                  if ($creator) {
                    if (-not $teamActivity.ContainsKey($creator)) {
                      $teamActivity[$creator] = @{ Name = $creator; Commits = 0; PRsCreated = 0; PRsMerged = 0; PRsReviewed = 0; WorkItemsAssigned = 0 }
                    }
                    $teamActivity[$creator].PRsCreated++
                    if ($pr.status -eq "completed") {
                      $teamActivity[$creator].PRsMerged++
                    }
                  }
                  if ($pr.reviewers) {
                    $reviewerList = $pr.reviewers -split "; "
                    foreach ($reviewer in $reviewerList) {
                      if ($reviewer -and $reviewer.Trim()) {
                        $reviewerName = $reviewer.Trim()
                        if (-not $teamActivity.ContainsKey($reviewerName)) {
                          $teamActivity[$reviewerName] = @{ Name = $reviewerName; Commits = 0; PRsCreated = 0; PRsMerged = 0; PRsReviewed = 0; WorkItemsAssigned = 0 }
                        }
                        $teamActivity[$reviewerName].PRsReviewed++
                      }
                    }
                  }
                }
                
                # Count work items assigned
                foreach ($wi in $workItemsList) {
                  if ($wi.assignedTo) {
                    $assignee = $wi.assignedTo
                    if (-not $teamActivity.ContainsKey($assignee)) {
                      $teamActivity[$assignee] = @{ Name = $assignee; Commits = 0; PRsCreated = 0; PRsMerged = 0; PRsReviewed = 0; WorkItemsAssigned = 0 }
                    }
                    $teamActivity[$assignee].WorkItemsAssigned++
                  }
                }
                
                # Calculate scores
                $userScores = foreach ($person in $teamActivity.Keys) {
                  $activity = $teamActivity[$person]
                  $score = ($activity.PRsMerged * $Global:ScoringWeights.PRsMerged) +
                           ($activity.PRsCreated * $Global:ScoringWeights.PRsCreated) +
                           ($activity.PRsReviewed * $Global:ScoringWeights.CodeReviews) +
                           ($activity.WorkItemsAssigned * $Global:ScoringWeights.WorkItems) +
                           ($activity.Commits * $Global:ScoringWeights.Commits)
                  
                  if ($score -gt 0) {
                    [PSCustomObject]@{
                      Name = $activity.Name
                      Score = [math]::Round($score, 1)
                      PRsMerged = $activity.PRsMerged
                      Reviews = $activity.PRsReviewed
                    }
                  }
                }
                $topContributors = $userScores | Sort-Object Score -Descending | Select-Object -First 5
              }
              
              # Build contributor items for the card
              $contributorItems = @()
              if ($topContributors.Count -gt 0) {
                $contributorItems += @{
                  type = "TextBlock"
                  text = "Top 5 Team Activity"
                  weight = "Bolder"
                  size = "Medium"
                  spacing = "Large"
                  separator = $true
                }
                $rank = 1
                foreach ($c in $topContributors) {
                  $medal = switch ($rank) { 1 { "1." } 2 { "2." } 3 { "3." } default { "$rank." } }
                  $contributorItems += @{
                    type = "ColumnSet"
                    spacing = "Small"
                    columns = @(
                      @{ type = "Column"; width = "auto"; items = @(@{ type = "TextBlock"; text = $medal; weight = "Bolder"; size = "Default" }) }
                      @{ type = "Column"; width = "stretch"; items = @(@{ type = "TextBlock"; text = $c.Name; weight = "Bolder"; wrap = $true }) }
                      @{ type = "Column"; width = "auto"; items = @(@{ type = "TextBlock"; text = "$($c.Score)"; color = "Good"; weight = "Bolder"; size = "Default" }) }
                    )
                  }
                  $rank++
                }
              }
              
              # Build card body
              $cardBody = @(
                        @{
                          type = "TextBlock"
                          size = "Large"
                          weight = "Bolder"
                          text = "Azure DevOps Statistics Report"
                          color = "Accent"
                        }
                        @{
                          type = "TextBlock"
                          text = "Weekly statistics collection completed successfully"
                          wrap = $true
                          spacing = "Small"
                        }
                        @{
                          type = "Container"
                          style = "emphasis"
                          items = @(
                            @{
                              type = "ColumnSet"
                              columns = @(
                                @{
                                  type = "Column"
                                  width = "stretch"
                                  items = @(
                                    @{ type = "TextBlock"; text = "Organization"; weight = "Bolder"; size = "Small" }
                                    @{ type = "TextBlock"; text = $orgName; spacing = "None" }
                                  )
                                }
                                @{
                                  type = "Column"
                                  width = "stretch"
                                  items = @(
                                    @{ type = "TextBlock"; text = "Duration"; weight = "Bolder"; size = "Small" }
                                    @{ type = "TextBlock"; text = $duration; spacing = "None" }
                                  )
                                }
                              )
                            }
                          )
                        }
                        @{
                          type = "ColumnSet"
                          separator = $true
                          spacing = "Medium"
                          columns = @(
                            @{
                              type = "Column"
                              width = "stretch"
                              items = @(
                                @{ type = "TextBlock"; text = "Users"; weight = "Bolder"; size = "Small"; color = "Accent" }
                                @{ type = "TextBlock"; text = $users; size = "ExtraLarge"; spacing = "None" }
                              )
                            }
                            @{
                              type = "Column"
                              width = "stretch"
                              items = @(
                                @{ type = "TextBlock"; text = "Repositories"; weight = "Bolder"; size = "Small"; color = "Accent" }
                                @{ type = "TextBlock"; text = $repos; size = "ExtraLarge"; spacing = "None" }
                              )
                            }
                            @{
                              type = "Column"
                              width = "stretch"
                              items = @(
                                @{ type = "TextBlock"; text = "Commits"; weight = "Bolder"; size = "Small"; color = "Accent" }
                                @{ type = "TextBlock"; text = $commits; size = "ExtraLarge"; spacing = "None" }
                              )
                            }
                          )
                        }
                        @{
                          type = "ColumnSet"
                          spacing = "Small"
                          columns = @(
                            @{
                              type = "Column"
                              width = "stretch"
                              items = @(
                                @{ type = "TextBlock"; text = "Pull Requests"; weight = "Bolder"; size = "Small"; color = "Accent" }
                                @{ type = "TextBlock"; text = $prs; size = "ExtraLarge"; spacing = "None" }
                              )
                            }
                            @{
                              type = "Column"
                              width = "stretch"
                              items = @(
                                @{ type = "TextBlock"; text = "Work Items"; weight = "Bolder"; size = "Small"; color = "Accent" }
                                @{ type = "TextBlock"; text = $workItems; size = "ExtraLarge"; spacing = "None" }
                              )
                            }
                            @{
                              type = "Column"
                              width = "stretch"
                              items = @()
                            }
                          )
                        }
              )
              
              # Add contributor items if we have them
              $cardBody += $contributorItems
              
              # Create Teams Adaptive Card message
              $teamsMessage = @{
                type = "message"
                attachments = @(
                  @{
                    contentType = "application/vnd.microsoft.card.adaptive"
                    contentUrl = $null
                    content = @{
                      '$schema' = "http://adaptivecards.io/schemas/adaptive-card.json"
                      type = "AdaptiveCard"
                      version = "1.4"
                      body = $cardBody
                      actions = @(
                        @{
                          type = "Action.OpenUrl"
                          title = "View Pipeline Summary"
                          url = $pipelineUrl
                        }
                        @{
              try {
                $response = Invoke-RestMethod -Uri $webhookUrl -Method Post -Body $body -ContentType "application/json"
                Write-Host "Teams notification sent successfully"
              }
              catch {
                Write-Host "##vso[task.logissue type=warning]Failed to send Teams notification: $($_.Exception.Message)"
              }
            displayName: 'Send Teams Notification'
            condition: succeededOrFailed()
            env:
              TEAMS_WEBHOOK: $(TEAMS_WEBHOOK_URL)
